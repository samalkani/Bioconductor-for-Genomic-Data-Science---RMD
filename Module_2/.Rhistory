pvalue=1-pchisq(lrts,df)
return(pvalue)
}
lrt.surv(mod1,mod2, 2)
Y=Surv(addicts$survt,addicts$status==1)
coxph(Y~ prison + dose + strata(clinic),data = addicts)
coxph(Y~prison + dose + clinic:prison + clinic:dose + strata(clinic),data=addicts)
addicts$clinic2=addicts$clinic-2
summary(coxph(Y~prison + dose + clinic2:prison +
clinic2:dose+strata(clinic2),data=addicts))
Y=Surv(addicts$survt,addicts$status==1)
mod1=coxph(Y~prison + dose + clinic,data=addicts)
cox.zph(mod1,transform=rank)
plot(cox.zph(mod1,transform=rank),se=F,var='clinic')
# Run Cox unadjusted model
Y=Surv(addicts$survt,addicts$status==1)
mod1=coxph(Y~prison + dose + clinic, data=addicts)
# Adjusted Cox model with the adjustments as follows
# PRISON = 0, DOSE=70 AND CLINIC=2
# CREATE DATA FRAME FIRST
pattern1=data.frame(prison=0,dose=70,clinic=2)
pattern1
# use summary function to get the Cox adjusted survival estimates
summary(survfit(mod1,newdata=pattern1))
# plot of the adjusted survival curve
plot(survfit(mod1, newdata=pattern1),
conf.int=F,main="Adjusted survival for prison=0, dose=70, clinic=2")
# stratified cox model
mod3=coxph(Y~prison + dose + strata(clinic),data=addicts)
# stratified cox model controlling for PRISON and DOSE
# Creation of one observation data frame, with the mean for prison and dose.
pattern2=data.frame(prison=0.46,dose=60.40)
#Plotting adjusted survival curve with clinic as the strata
plot(survfit(mod3,newdata=pattern2), conf.int=F, lty=c("solid","dashed"),
col=c("red","green"), main="Survival curves for clinic, adjusted for prison and dose")
legend("topright",c("Clinic 1","Clinic 2"),lty=c("solid","dashed"), col=c("red","green"))
# Plotting adjusted log-log survival curves for clinic
plot(survfit(mod3,newdata = pattern2),fun="cloglog",
main="Log-Log curves for clinic, adjusted for prison and dose")
# Plotting adjusted log-log survival curves for clinic with the time scale not logged
sum.mod3=summary(survfit(mod3,newdata=pattern2))
# similar code to section 3
sum.mod4=data.frame(sum.mod3$strata,sum.mod3$time,sum.mod3$surv)
colnames(sum.mod4)=c("clinic","time","survival")
clinic1=sum.mod4[sum.mod4$clinic=="clinic=1",]
clinic2=sum.mod4[sum.mod4$clinic=="clinic=2",]
# plot
plot(clinic1$time,log(-log(clinic1$survival)),xlab="survival time in days",ylab="log-log survival",xlim=c(0,800),col=
"red",type='l',lty="solid", main="log-log curves stratified by
clinic, adjusted for prison, dose")
par(new=T)
plot(clinic2$time,log(-log(clinic2$survival)),axes=F,xlab=
"survival time in days",ylab="log-log survival",col="green",
type='l',lty="dashed")
legend("bottomright",c("Clinic 1","Clinic 2"), lty=c("solid","dashed"),col=c("red","green"))
par(new=F)
# Transforming the dataset into counting process (start, stop) format
# to run an extended Cox model
addicts.cp=survSplit(addicts,cut=addicts$survt[addicts$status==1],
end="survt", event="status",start="start")
nrow(addicts.cp)
# Creation of a new variable based on multiplying the variable dose with the log of the survival
# time. This variable is created because we suspect that the variable dose has failed the proportional
# hazards assumption.
addicts.cp$logtdose=addicts.cp$dose*log(addicts.cp$survt)
# For the new variable DOSE=ln(DOSE)*T, which varies over time we print observation 106
# who had an event at time = 35 days for a selected group of variables
addicts.cp[addicts.cp$id==106,c('id','start','survt','status','dose','logtdose')]
# Run the extended Cox model with the inclusion of predictors;
# PRISON, DOSE, and CLINIC, and  time dependent variable LOGTDOSE
coxph(Surv(addicts.cp$start,addicts.cp$survt,addicts.cp$status) ~
prison + dose + clinic + logtdose + cluster(id),data=addicts.cp)
# Running the extended Cox model with a time cutpoint of 365 days
# Essentially splitting the time of the study into observations
# below 365 days and observations above 365 days
addicts.cp365=survSplit(addicts,cut=365,end="survt", event="status",start="start")
# Defining the timepoint 365 days and the two time intervals (heaviside functions) above and below 365 days
addicts.cp365$hv1=addicts.cp365$clinic*(addicts.cp365$start<365)
addicts.cp365$hv2=addicts.cp365$clinic*(addicts.cp365$start>=365)
# Sort the dataset by variables ID and START
addicts.cp365=addicts.cp365[order(addicts.cp365$id,addicts.cp365$start),]
# Printout of the first 10 observations for selected variables
addicts.cp365[1:10,c('id','start', 'survt','status','clinic','hv1','hv2')]
# Running an extended Cox model with heaviside functions (time intervals)
# Define the object for the response variable
Y365=Surv(addicts.cp365$start,addicts.cp365$survt,addicts.cp365$status)
# Run the Cox extended model with the two heaviside functions
coxph(Y365 ~ prison + dose + hv1 + hv2 + cluster(id), data=addicts.cp365)
# Handling ties in the two different time intervals (heaviside functions)
coxph(Y365 ~ prison + dose +hv1 + hv2,data=addicts.cp365,method="breslow")
# Run Cox extended model with one heaviside function and the variable CLINIC
coxph(Y365 ~ prison + dose + clinic + hv2 + cluster(id),data=addicts.cp365)
# log-log survival vs time in days using log-time plot
plot(survfit(Y~addicts$clinic),fun="cloglog",xlab="time in days using log-
arithmic scale",ylab="log-log survival", main="log-log curves by clinic")
# Exponential AFT model
modpar1=survreg(Surv(addicts$survt,addicts$status) ~ prison + dose +
clinic,data=addicts,dist="exponential")
summary(modpar1)
# Weibull AFT model
modpar2=survreg(Surv(addicts$survt,addicts$status)
~ prison + dose + clinic,data=addicts,dist="weibull")
summary(modpar2)
# Use of predict function to estimate then median or any other quantile time to event
# for any pattern of co-variates
# Co-variate pattern; PRISON=1, DOSE=50 AND CLINIC=1
pattern1=data.frame(prison=1,dose=50,clinic=1)
pct=c(0.25,0.50,0.75)
days=predict(modpar2,newdata=pattern1,type="quantile",p=pct)
cbind(pct,days) # adds vectors pct and days to create a matrix containing both vectors
# Creating a plot for individual with covariate pattern;  PRISON=1, DOSE=50 AND CLINIC=1
pct2=0:100/100
days2=predict(modpar2,newdata=pattern1,type="quantile",p=pct2)
survival=1-pct2
plot(days2,survival,xlab="survival time in days",ylab="survival
probabilities",main="Weibull survival estimates for prison=0,
dose=50, clinic=1",xlim=c(0,800))
# log-logistic AFT model
modpar3=survreg(Surv(addicts$survt,addicts$status)~
prison + dose + clinic,data=addicts,dist="loglogistic")
summary(modpar3)
# Kaplan Meier (KM) estimates object
kmfit2=survfit(Surv(addicts$survt,addicts$status)~addicts$clinic)
plot(log(kmfit2$time),log(kmfit2$surv/(1-kmfit2$surv)))
# Re-run the stratified Cox model without the Frailty (random) component.
Y=Surv(addicts$survt,addicts$status==1)
coxph(Y~ prison + dose + strata(clinic),data=addicts)
# Run the stratified Cox model with Frailty (random) component.
coxph(Y~ prison + dose + strata(clinic) + frailty(clinic,distribution="gamma"),data=addicts)
# Run the Cox model without the CLINIC variable and without FRAILTY.
coxph(Y~ prison + dose,data=addicts)
# Run the Cox model without the CLINIC variable and with FRAILTY
coxph(Y~ prison + dose + frailty(clinic,distribution="gamma"),data=addicts)
# Detailed output for the Cox model without CLINIC variable and with FRAILTY
summary(coxph(Y~ prison + dose + frailty(clinic,distribution="gamma"), data=addicts))
library(base64enc)
install.packages("AHPtools")
knitr::opts_chunk$set(echo = TRUE)
summary(cars)
plot(pressure)
sessionInfo()
sessionInfo()
sessionInfo()
load("C:/Users/Ajay_/S01 - Machine-Learning-A-Z-Codes-Datasets/Machine-Learning-A-Z-Codes-Datasets/Part 1 - Data Preprocessing/Section 2 -------------------- Part 1 - Data Preprocessing --------------------/R/.RData")
R.version.string
install.packages("updateR")
library(updateR)
updateR()
update.packages()
R.version.string
q()
q()
R.version
# 2. Load AnnotationHub
library(AnnotationHub)
# 3. Creating a local annotation hub
ah = AnnotationHub()
ah
# 4. Look at first element
ah[1]
library(rtracklayer)
# 7. Retrieving objects from annotation hub
ah[[1]]
unique(ah$dataprovider)
unique(ah$dataprovider)
# 9. Information on Species in the ah database
unique(ah$species)
# 11. Information Specific to Homo sapiens
ah = subset(ah, species == "Homo sapiens")
ah
# 12. Information specific to Histomodification
query(ah, "H3K4me3")
# 13. Information on a specific cell line and Histomodification
query(ah, c("H3K$me3", "Gm12876"))
library(BiocHubsShiny)
BiocHubsShiny()
ah = AnnotationHub()
ah
ah[1]
ah[1]
ah[[1]]
unique(ah$dataprovider)
unique(ah$species)
ah = subset(ah, species == "Homo sapiens")
ah
query(ah, "H3K4me3")
query(ah, c("H3K$me3", "Gm12878"))
BiocHubsShiny()
BiocHubsShiny(ah)
ah2 <- query(ah, "H3K4me3")
BiocHubsShiny(ah2)
ah = AnnotationHub()
ah
ah[1]
ah[[1]]
unique(ah$dataprovider)
unique(ah$species)
ah = subset(ah, species == "Homo sapiens")
ah
query(ah, "H3K4me3")
query(ah, c("H3K$me3", "Gm12878"))
ah2 <- query(ah, "H3K4me3")
ah2
BiocHubsShiny(ah2)
BiocHubsShiny()
query(ah, "H3K4me3")
BiocHubsShiny()
ah = AnnotationHub()
ah
ah[1]
ah[[1]]
unique(ah$dataprovider)
unique(ah$species)
ah = subset(ah, species == "Homo sapiens")
ah
query(ah, "H3K4me3")
query(ah, c("H3K$me3", "Gm12878"))
BiocHubsShiny()
# 13. Information on a specific cell line and Histomodification
query(ah, c("H3K4me3", "Gm12878"))
BiocHubsShiny()
print(ah_meta)
table(ah_meta)
View(ah)
view(ah_meta)
View(ah_meta)
table(ah_meta)
print(ah_meta)
table(ah_meta)
BiocHubsShiny()
print(ah_meta)
load("D:/Ajay Files/Genomic Data Science Courses/Genomic Data Science/Course 5 - Bioconductor for Genomic Data Science/Module_1/.RData")
load("D:/Ajay Files/Genomic Data Science Courses/Genomic Data Science/Course 5 - Bioconductor for Genomic Data Science/Module_1/.RData")
load("D:/Ajay Files/Genomic Data Science Courses/Genomic Data Science/Course 5 - Bioconductor for Genomic Data Science/Module_1/.RData")
write.csv(ah_meta)
library(AnnotationHub)
library(Biostrings)
library(BSgenome)
library(GenomicRanges)
library(rtracklayer)
library(Rsamtools)
library(GenomicFeatures)
# 1. B. Load the hg19 library
# if (!require("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
BiocManager::install("BSgenome.Hsapiens.UCSC.hg19")
# 1. C. Load the Library
library(BSgenome.Hsapiens.UCSC.hg19)
# 1. D. Count total bases on chr22
alphabet_frequency <- alphabetFrequency(Hsapiens$chr22)
total_bases <- sum(alphabet_frequency[c('A','G','C','T')])
# 1. D. Count total bases on chr22
alphabet_frequency <- alphabetFrequency(Hsapiens$chr22)
alphabet_frequency
total_bases <- sum(alphabet_frequency[c('A','G','C','T')])
total_bases
# 1. E. Count GC bases on chr22
letter_freq <- letterFrequency(Hsapiens$chr22, "GC")
letter_freq
# 1. F. Calculate GC ratio
GC_content <- letter_freq/total_bases
GC_content
# 2. A. Retrieve record
ah <- AnnotationHub()
ah
H3K27me3_qh <- query(ah, c("H3K27me3", "E003", "narrowPeak"))
H3K27me3_qh
H3K27me3_record <- H3K27me3_qh[["AH29892"]]
H3K27me3_record
setwd("D:/Ajay Files/Genomic Data Science Courses/Genomic Data Science/Course 5 - Bioconductor for Genomic Data Science/Module_2")
# 2. B. Extract chr 22 and sequences
H3K27me3_chr22 <- subset(H3K27me3_record, seqnames == "chr22")
H3K27me3_chr22
H3K27me3_chr22_views <- Views(Hsapiens, H3K27me3_chr22)
H3K27me3_chr22_views
# 2. C. Calculate mean GC content
GC_contents <- letterFrequency(H3K27me3_chr22_views, "GC", as.prob = TRUE)
head(GC_contents)
tail(GC_contents)
mean_GC <- mean(GC_contents)
mean_GC
# 3.	Background - The “narrowPeak” regions includes information on a value
# they call “signalValue”.
# What is the correlation between GC content and “signalValue” of these
# regions (on chr22)?
signal_value <- mcols(H3K27me3_chr22_views)$signalValue
signal_value
cor(signal_value, GC_contents)
# 3.	Background - The “narrowPeak” regions includes information on a value
# they call “signalValue”.
# What is the correlation between GC content and “signalValue” of these
# regions (on chr22)?
signal_value <- mcols(H3K27me3_chr22_views)$signalValue
head(signal_value)
tail(signal_value)
cor(signal_value, GC_contents)
# 4.	Background: - The “narrowPeak” regions are presumably reflective of a ChIP
# signal in these regions. To confirm this, we want to obtain the “fc.signal”
# data from AnnotationHub package on the same cell line and histone modification.
# This data represents a vector of fold-change enrichment of ChIP signal over input.
# What is the correlation between the “signalValue” of the “narrowPeak” regions
# and the average “fc.signal” across the same regions?
# Clarification: First compute the average “fc.signal” for across each region,
# for example using “Views”; this yields a single number of each region. Next
# correlate these numbers with the “signalValue” of the “narrowPeaks”.
# 4. A. Retrieve record
H3K27me3_fc <- query(ah, c("H3K27me3", "E003", "fc.signal"))
H3K27me3_fc
H3K27me3_fc_record <- H3K27me3_fc[["AH32033"]]
H3K27me3_fc_record
# 4. B. Get subset data on chr22
gr22 <- GRanges(seqnames = "chr22", ranges = IRanges(start = start(Hsapiens$chr22), end = end(Hsapiens$chr22)))
gr22
H3K27me3_fc_gr <- import(H3K27me3_fc_record, which = gr22, as = "Rle")
H3K27me3_fc_gr
H3K27me3_fc_gr22 <- H3K27me3_fc_gr$chr22
H3K27me3_fc_gr22
# 4. C. View fc.signal data
fc.signal <- Views(H3K27me3_fc_gr22, start = start(H3K27me3_chr22), end = end(H3K27me3_chr22))
fc.signal
# 4. D. Calculate the correlation between the average of fc.signal and signalValue
fc.signal_mean <- mean(fc.signal)
fc.signal_mean
cor(fc.signal_mean, signal_value)
# 4. D. Calculate the correlation between the average of fc.signal and signalValue
fc.signal_mean <- mean(fc.signal)
head(fc.signal_mean)
tail(fc.signal_mean)
cor(fc.signal_mean, signal_value)
# 5.	Referring to the objects made and defined in the previous question.
# How many bases on chr22 have an fc.signal greater than or equal to 1?
sum(H3K27me3_fc_gr22 >= 1)
# 6.	Background: The H1 stem cell line is an embryonic stem cell line, a
# so-called pluripotent cell. Many epigenetic marks change upon differentiation.
# We will examine this. We choose the cell type with Roadmap ID “E055” which is
# foreskin fibroblast primary cells.
# We will use the “fc.signal” for this cell type for the H3K27me3 mark, on chr22.
# We now have a signal track for E003 and a signal track for E055. We want to
# identify regions of the genome which gain H3K27me3 upon differentiation.
# These are regions which have a higher signal in E055 than in E003. To do this
# properly, we would need to standardize (normalize) the signal across the two
# samples; we will ignore this for now.
# Identify the regions of the genome where the signal in E003 is 0.5 or lower
# and the signal in E055 is 2 or higher.
# Tip: If you end up with having to intersect two different Views, note that you
# will need to convert the Views to IRanges or GRanges first with \verb|ir <- as
# (vi, "IRanges")|ir <- as(vi, "IRanges").
# 6. A. Find the specific record
H3K27me3_E055 <- query(ah, c("H3K27me3", "E055"))
H3K27me3_E055
H3K27me3_E055_record <- H3K27me3_E055[["AH32470"]]
H3K27me3_E055_record
# 6. B. Get subset data on chr22
gr_chr22 <- GRanges(seqnames = "chr22", ranges = IRanges(start = start(Hsapiens$chr22), end = end(Hsapiens$chr22)))
gr_chr22
H3K27me3_fc_gr_E055 <- import(H3K27me3_E055_record, which = gr_chr22, as = "Rle")
H3K27me3_fc_gr_E055
H3K27me3_fc_gr22_E055 <- H3K27me3_fc_gr_E055$chr22
H3K27me3_fc_gr22_E055
# 6. C. Identify region
region_E003 <- as(slice(H3K27me3_fc_gr22, upper = 0.5), "IRanges")
region_E003
region_E055 <- as(slice(H3K27me3_fc_gr22_E055, lower = 2), "IRanges")
region_E055
inter_region <- intersect(region_E003, region_E055)
inter_region
sum(width(inter_region))
# 7. A. Retrieve the cpg
ah_human <- subset(ah, species == "Homo sapiens")
ah_human
ah_human_cpg <- query(ah_human, "CpG Islands")
ah_human_cpg
ah_human_cpg_record <- ah_human_cpg[["AH5086"]]
ah_human_cpg_record
# 7. B. Get subset data on chr22
ah_human_cpg_chr22 <- subset(ah_human_cpg_record, seqnames == "chr22")
ah_human_cpg_chr22
ah_human_cpg_chr22_views <- Views(Hsapiens, ah_human_cpg_chr22)
ah_human_cpg_chr22_views
# 7. C. Calculate observed GC bases
observed_GC <- dinucleotideFrequency(ah_human_cpg_chr22_views)[,7]/width(ah_human_cpg_chr22_views)
observed_GC
ah_human_cpg_chr22_views[,7]
dinucleotideFrequency(ah_human_cpg_chr22_views)[,7]
# 7. C. Calculate observed GC bases
observed_GC <- dinucleotideFrequency(ah_human_cpg_chr22_views)[,7]/width(ah_human_cpg_chr22_views)
observed_GC
# 7. D. Calculate expected GC bases
freq_C <- letterFrequency(ah_human_cpg_chr22_views, "C")
freq_C
freq_G <- letterFrequency(ah_human_cpg_chr22_views, "G")
freq_G
expected_GC <- (freq_C/width(ah_human_cpg_chr22_views))*(freq_G/width(ah_human_cpg_chr22_views))
expected_GC
# 7. C. Calculate observed GC bases
observed_GC <- dinucleotideFrequency(ah_human_cpg_chr22_views)[,7]/width(ah_human_cpg_chr22_views)
observed_GC
# 7. C. Calculate observed GC bases
observed_GC <- dinucleotideFrequency(ah_human_cpg_chr22_views)[,7]/width(ah_human_cpg_chr22_views)
head(observed_GC)
tail(observed_GC)
# 7. D. Calculate expected GC bases
freq_C <- letterFrequency(ah_human_cpg_chr22_views, "C")
head(freq_C)
tail(freq_C)
freq_G <- letterFrequency(ah_human_cpg_chr22_views, "G")
head(freq_G)
tail(freq_G)
expected_GC <- (freq_C/width(ah_human_cpg_chr22_views))*(freq_G/width(ah_human_cpg_chr22_views))
head(expected_GC)
tail(expected_GC)
# 7. E. Calculate the average observed-to-expected ratio of CpG dinucleotides
mean(observed_GC/expected_GC)
# 8.	Background: A TATA box is a DNA element of the form “TATAAA”. Around 25%
# of genes should have a TATA box in their promoter. We will examine this statement.
# How many TATA boxes are there on chr 22 of build hg19 of the human genome?
# Clarification: You need to remember to search both forward and reverse strands.
TATA_boxes <- countPattern("TATAAA", Hsapiens$chr22) + countPattern("TATAAA", reverseComplement(Hsapiens$chr22))
TATA_boxes
# 9.	How many promoters of transcripts on chromosome 22 containing a coding
# sequence, contains a TATA box on the same strand as the transcript?
# Clarification: Use the TxDb.Hsapiens.UCSC.hg19.knownGene package to define
# transcripts and coding sequence. Here, we defined a promoter to be 900bp
# upstream and 100bp downstream of the transcription start site.
# 9. A. Load the TxDb.Hsapiens.UCSC.hg19 library
# if (!require("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
BiocManager::install("TxDb.Hsapiens.UCSC.hg19.knownGene")
# 9. C. Identify the record and create the GRanges
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
# 9. A. Load the TxDb.Hsapiens.UCSC.hg19 library
# if (!require("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
BiocManager::install("TxDb.Hsapiens.UCSC.hg19.knownGene")
# 9. B. Load the Library
library(BSgenome.Hsapiens.UCSC.hg19)
# 9. C. Identify the record and create the GRanges
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
BiocManager::install("TxDb.Hsapiens.UCSC.hg19.knownGene")
# 9. A. Load the TxDb.Hsapiens.UCSC.hg19 library
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("TxDb.Hsapiens.UCSC.hg19.knownGene")
# 9. B. Load the Library
library(BSgenome.Hsapiens.UCSC.hg19)
# 9. C. Identify the record and create the GRanges
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
library(BSgenome.Hsapiens.UCSC.hg19.knownGene)
# 9. B. Load the Library
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
# 9. C. Identify the record and create the GRanges
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
txdb
gr <- GRanges(seqnames = "chr22", ranges = IRanges(start = start(Hsapiens$chr22), end = end(Hsapiens$chr22)))
gr
# 9. A. Load the TxDb.Hsapiens.UCSC.hg19 library
# if (!require("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
BiocManager::install("TxDb.Hsapiens.UCSC.hg19.knownGene")
# 9. B. Load the Library
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
# 9. C. Identify the record and create the GRanges
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
txdb
gr <- GRanges(seqnames = "chr22", ranges = IRanges(start = start(Hsapiens$chr22), end = end(Hsapiens$chr22)))
gr
# 9. D. find promoters of transcripts on chr 22
gr_trans_chr22 <- subsetByOverlaps(transcripts(txdb), gr, ignore.strand = TRUE)
gr_trans_chr22
proms <- promoters(gr_trans_chr22, upstream = 900, downstream = 100)
proms
# 9.  E. find coding sequences on chr 22
gr_cds_chr22 <- subsetByOverlaps(cds(txdb), gr, ignore.strand = TRUE)
gr_cds_chr22
# 9. F. find overlaps between promoters of transcripts and coding sequences
proms_cds <- findOverlaps(proms, gr_cds_chr22)
proms_cds
# 9. G. calculate TATA box on overlaps
count = 0
for (i in unique(queryHits(proms_cds))){
proms_cds_view <- Views(Hsapiens, proms[i])
count = count + vcountPattern("TATAAA", DNAStringSet(proms_cds_view))
}
count
count
# 10.	Background: It is possible for two promoters from different transcripts to
# overlap, in which case the regulatory features inside the overlap might affect
# both transcripts. This happens frequently in bacteria.
# How many bases on chr22 are part of more than one promoter of a coding sequence?
# Clarification: Use the TxDb.Hsapiens.UCSC.hg19.knownGene package to define
# transcripts and coding sequence. Here, we define a promoter to be 900bp
# upstream and 100bp downstream of the transcription start site. In this case,
# ignore strand in the analysis.
# 10. A. Calculate transcript lengths
trans_len_chr22 <- transcriptLengths(txdb, with.cds_len = TRUE)
trans_len_chr22
trans_len_chr22 <- trans_len_chr22[trans_len_chr22$cds_len > 0,]
trans_len_chr22
# 10. A. Calculate transcript lengths
trans_len_chr22 <- transcriptLengths(txdb, with.cds_len = TRUE)
head(trans_len_chr22)
tail(trans_len_chr22)
trans_len_chr22 <- trans_len_chr22[trans_len_chr22$cds_len > 0,]
head(trans_len_chr22)
tail(trans_len_chr22)
# 10. B. Find promoters from different transcripts to overlap
trans_eval <- proms[mcols(proms)$tx_id %in% trans_len_chr22$tx_id]
trans_eval
result = sum(coverage(trans_eval) > 1)
result
result["chr22"]
